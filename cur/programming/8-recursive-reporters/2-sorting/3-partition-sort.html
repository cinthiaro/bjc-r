<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
        <title>Unit 8 Lab 2: Sorting, Page 3</title>
    </head>
    
    <body>
        <h2>Ordenando una partici&oacute;n</h2>
        <div class="todo">
            <p>PG: Scrap. Scrap all. Two reasons. (1) While sorting algorithms is an important and traditional CS topic, it's not obvious to me why they have any important role in an attract-them-in course. These are TiF for interested kids. (2) If our reason for this unit is to teach recursion, sorting is a distraction, and harder than we need to be. If anything at all, it's a culmination, not a start. I'd be happier showing kids how to march down a list and act on it. With HoFs or recursion. Power and utility. That's currently in Lab 4. Maybe earlier even than this unit?</p>
            <p>BH: Definitely replace with mergesort.  Partition sort isn't guaranteed O(n log n); its analysis was awarded a PhD at Stanford.  Mergesort is straightforward.</p>
            <p>MF: I said keep, but I find these pages to be almost to much, and I want to review them. Also, I want to think about whether it would make sense to revisit timing and efficiency here.</p>
        </div>
        
        <p>
            Otro tipo de uso com&uacute;n es el llamado <strong>ordenando una partici&oacute;n</strong>. As&iacute; es como funciona:
            </p>
<ul>
                <li><strong>Paso 1.</strong> En una lista sin clasificar, selecciona el primer elemento de la lista (<em>que probablemente no sea el elemento que deber&iacute;a aparecer primero despu&eacute;s de la clasificaci&oacute;n</em>). Este elemento se llama <strong>pivote</strong>.</li>
<div class="todo">BH: About step 2 and its yellow box:  This handwaves away the deep issue, which is that sometimes the sort key is smaller than the sort record, so two records may sort alike but not be equal.  I'm not sure if this has to be addressed but maybe it should be mentioned in the TG. BK: I didn't understand what this comment means, sorry.</div>
                <li>
<div class="sidenote">An item is "with the pivot" only if it has the same value as the pivot.</div><strong>Paso 2.</strong> Para cada elemento de la lista, decide si viene antes del pivote, con el pivote, o despu&eacute;s del pivote.</li>
                <li><strong>Paso 3.</strong> Divide los datos en tres categor&iacute;as: elementos antes del pivote, con el pivote, despu&eacute;s del pivote. Las listas antes y despu&eacute;s del pivote no est&aacute;n ordenadas.</li>
                <li><strong>Paso 4.</strong> En una lista sin clasificar, seleccione el primer elemento de la lista Si hay elementos despu&eacute;s del pivote, usa un tipo de partici&oacute;n para ponerlos en orden.</li>
				<li><strong>Paso 5.</strong> La lista ordenada se hace a partir de la adici&oacute;n de las tres listas de resultados juntas.</li>
            </ul>
        <p></p>

		<div class="takeNote">Los nombres no se ordenan al colocarlos antes o despu&eacute;s de un pivote. Para <img src="/bjc-r/img/8-recursive-reporters/eightnames.png" alt="list{Emma, Olivia, Sophia, Isabella, Ava, Mia, Emily, Abigail}" title="list{Emma, Olivia, Sophia, Isabella, Ava, Mia, Emily, Abigail}">,este es el estado despu&eacute;s de la primera divisi&oacute;n por medio de pivotes: el <strong>pivot</strong>e es Emma, la lista antes del pivote es <var>{Ava, Abigail}</var>,&nbsp; y la lista despu&eacute;s del pivote es <var>{Olivia, Sophia, Isabella, Mia, Emily}</var>. El proceso de clasificaci&oacute;n contin&uacute;a en estas dos listas m&aacute;s peque&ntilde;as sin clasificar.</div>

        <div class="forYouToDo" id="first">
            <ol>
                <li>Explora el tipo de partici&oacute;n antes de escribir cualquier c&oacute;digo. Con tu clase, lev&aacute;ntate y forma una l&iacute;nea. Luego, sigue el proceso de clasificaci&oacute;n de las particiones para poner a todos en orden, de menor a mayor, por el n&uacute;mero de su domicilio.</li>
                <li>&iquest;C&oacute;mo es que una partici&oacute;n es un ejemplo de recursividad? &iquest;Cu&aacute;l es el caso base?</li>
            </ol>
        </div>

<!--        <div class="sidenote">The name <strong>quicksort</strong> can refer to many different algorithms, all with the same goal: sort, quick! This page describes a standard partition sort.</div> -->
<!--        <p>A video of one version of partition sort can be found <a href="http://www.youtube.com/watch?v=aQiWF4E8flQ">here.</a> There are minor differences: the video uses the last item as pivot, and calls the algorithm "quick sort".</p> -->
<div class="todo">We may want to make our own video to show this in action. The linked video is not quite right and has been killed off.</div>
        <p>Para escribir un bloque de <code>clasificaci&oacute;n de particiones</code> en Snap<em>!</em>, necesitar&aacute;s un c&oacute;digo para un caso base, y un c&oacute;digo que siga los pasos del tipo de partici&oacute;n.</p>

        <div class="forYouToDo">
            <ol start="3">
                <li>
                     <a class="run" href="/bjc-r/prog/8-recursive-reporters/appendblock.xml"><img class="inline" src="/bjc-r/img/icons/load-save.png" alt="Click here to load this file. Then save it to your Snap! account." title="Click here to load this file. Then save it to your Snap! account."></a><br>  Examina este nuevo proyecto que contiene el bloque de <code>ap&eacute;ndices</code>&nbsp; (en el men&uacute; Variables).
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/appendblock.png" alt="append(list{Ava, Abigail})(list{Emma})(list{Olivia, Sophia, Isabella, Mia, Emily})" title="append(list{Ava, Abigail})(list{Emma})(list{Olivia, Sophia, Isabella, Mia, Emily})">
                </li>
                <li>Describe lo que hace el bloque <code>ap&eacute;ndice</code>.</li>
                <li>
<div class="sidenoteBig">Tendr&aacute;s que averiguar c&oacute;mo colocar los elementos en las tres categor&iacute;as, y c&oacute;mo crear una lista final para la salida.</div>Construye el tipo de <code>partici&oacute;n<span style="font-family: serif;"> </span></code>recursiva del reportero. Su salida, para cualquier lista, deber&iacute;a ser la misma que la salida para el <code>tipo de selecci&oacute;n</code>.</li>
            </ol>
        </div>

		<div class="sidenoteBig">        
            <a href="#hint-1" data-toggle="collapse" class="collapsed" title="Example">Revela un ejemplo.</a>
            <div id="hint-1" class="collapse">
            	Por ejemplo, digamos que ayer ten&iacute;as una gran lista ordenada, y hoy a&ntilde;ades unos cuantos elementos nuevos, as&iacute; que tienes que volver a ordenar la lista. Un algoritmo de clasificaci&oacute;n de prop&oacute;sito general no aprovechar&aacute; el funcionamiento casi en orden de su entrada. Pero el tipo de <em>inserci&oacute;n,</em> un algoritmo que es lento en general, maneja este caso especial r&aacute;pidamente.
            </div>
        </div>
		<p>&iquest;Por qu&eacute; hay diferentes algoritmos de clasificaci&oacute;n? Algunos algoritmos de clasificaci&oacute;n tardan m&aacute;s que otros en ejecutarse, pero incluso un algoritmo que es lento en general puede ser &uacute;til en casos especiales.</p>

        <div class="ifTime">
            <ol start="6">
                <li>Tambi&eacute;n podr&iacute;as usar una larga lista de nombres aqu&iacute;.<br>Haz una lista de 500 elementos de n&uacute;meros aleatorios, y luego ordena la lista usando los tres algoritmos de clasificaci&oacute;n que construiste en este laboratorio. Lleva un registro de los tiempos:<br>
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/compare-time.png" alt="set(biglist) to (Empty list); repeat(500){add(pick random(1) to (2000) to (biglist)}; reset timer; say(sort(biglist)); set(time) to (timer)" title="set(biglist) to (Empty list); repeat(500){add(pick random(1) to (2000) to (biglist)}; reset timer; say(sort(biglist)); set(time) to (timer)">
                </li>
                <li>&iquest;Qu&eacute; algoritmo fue m&aacute;s r&aacute;pido? &iquest;Por qu&eacute; este tipo de algoritmo podr&iacute;a ejecutarse m&aacute;s r&aacute;pido?</li>
                <!--<p>In that script we've renamed <code>sort</code> to <code>merge&nbsp;sort</code>, and used the name <code>your&nbsp;sort</code> for the one you wrote earlier.  <code>Biglist</code>, <code>your-time</code>, and <code>merge-time</code> are global variables.</p>
                <p>Most likely, mergesort will take less than four seconds, while the one you wrote earlier will take more than 15 seconds. That's because we're betting your earlier one positions one number at a time in the sorted list, whereas mergesort cuts the list into two half-size lists and sorts them separately, which is inherently more efficient. If you make the input list ten times as long, a one-at-a-time sort will take 100 times as long to compute the result, whereas mergesort will only take about 30 times as long.</p> -->
            </ol>
        </div>

    

</body></html>
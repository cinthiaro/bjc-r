<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        
        <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
        <title>Unit 8 Lab 3: Recursive Reporter Projects, Page 4</title>
    </head>
    
    <body>
        <h2>Conversi&oacute;n base</h2>
        <div class="todo">
            <p>BH: End of lab 4.</p>
            <p>MF: I want to review/revise.</p>
        </div>
        
        <p>Aqu&iacute; hay una soluci&oacute;n para la conversi&oacute;n binaria de n&uacute;meros enteros no negativos:</p>
        <p><img class="indent" src="/bjc-r/img/8-recursive-reporters/tobinary.png" alt="decimal-&gt;binary(number){if(number&lt;2){report(number)}else{report(join(decimal-&gt;binary(floor(number/2)))(number mod 2))}}" title="decimal-&gt;binary(number){if(number&lt;2){report(number)}else{report(join(decimal-&gt;binary(floor(number/2)))(number mod 2))}}"></p>
        <p>Si un n&uacute;mero puede ser representado con un solo d&iacute;gito, lo usamos como caso base. En binario, los &uacute;nicos n&uacute;meros que pueden ser representados con un solo d&iacute;gito son el 0 y el 1, as&iacute; que hacemos una prueba para ver si el n&uacute;mero es menor de 2. Si es as&iacute;, lo reportamos.</p>
        <p></p>
<div class="sidenote">Puede ser sorprendente que no usemos un combinador aritm&eacute;tico, pero el resultado deseado es un <em>n&uacute;mero</em>, una cadena de texto. Por eso el combinador es una operaci&oacute;n en cadena.</div>En el caso recursivo, el d&iacute;gito binario m&aacute;s a la derecha es el restante al dividir el n&uacute;mero por 2. Los otros d&iacute;gitos vienen de una llamada recursiva sobre el cociente al dividirlo por 2. El combinador se une porque queremos encadenar los d&iacute;gitos.
<p></p>

        <div class="forYouToDo" id="first">
           <div class="todo">Images should be redone so they are the same size (zoom 1.5). --MF</div>
           <ol>
                <li>
                    Escribe el bloque <code>base7</code>, que muestra un n&uacute;mero en base 7.<br>
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/base7example.png" alt="base7( 9827), reporting 40436" title="base7( 9827), reporting 40436">
                </li>
                <li>
                    Generaliza el patr&oacute;n con un bloque <code>base</code> que toma la base como una segunda entrada:<br>
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/base2.png" alt="(9827)base(2), reporting 10011001100011" title="(9827)base(2), reporting 10011001100011">
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/base7.png" alt="(9827)base(7), reporting 40436" title="(9827)base(7), reporting 40436"><br>
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/base8.png" alt="(9827)base(8), reporting 23143" title="(9827)base(8), reporting 23143">
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/base10.png" alt="(9827)base(10), reporting 9827" title="(9827)base(10), reporting 9827"><br>
                    
                </li>
                <li>
                    <div class="sidenote">Snap<em>!</em> mostrar&aacute; este n&uacute;mero en decimal, pero est&aacute;s convirtiendo un <em>n&uacute;mero</em>, no una cadena de d&iacute;gitos.</div>Escribe la funci&oacute;n inverse <code>de base</code> que toma una cadena (texto) de d&iacute;gitos y una base como entradas, e informa el n&uacute;mero correspondiente.<br>
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/frombase.png" alt="(23143)from base(8) reporting 9827" title="(23143)from base(8) reporting 9827">
                </li>
            </ol>
        </div>

        <div class="ifTime">
            <ol start="4">
                <li>Mejora el bloque <code>base</code> para que pueda subir a base 36 utilizando las letras <code>a</code>‒<code>z</code> como d&iacute;gitos con valores 10‒35.<br>
                <img class="indent" src="/bjc-r/img/8-recursive-reporters/common.png" alt="(32562)base(15), reporting 99ac" title="(32562)base(15), reporting 99ac">
                    <img class="indent" src="/bjc-r/img/8-recursive-reporters/w00zy.png" alt="(53749006)base(36) reporting w00zy" title="(53749006)base(36) reporting w00zy">
                </li>
                <li>Mejora el bloque <code>de base</code> para apoyar bases de hasta 36 de la misma manera.</li>
            </ol>
        </div>

<!--        <div class="takeItFurther" id="first">
		
       <p> 	Long ago, when computer circuits were very unreliable, some computers used a representation called <em>biquinary,</em> which used decimal digits, each of which was represented using five bits, of which exactly two had to be 1, and the other three had to be 0.  The five bits represented the values 0, 1, 2, 4, and 7. (Yes, that's a strange set of bit values.  Bear with us.)</p>
            <div class="comment">GH feedback 8/2/15: I don't understand the question being asked in "Take It Further" #6. It's unclear. (It's letter B, now. --MF)</div>
            <ol style="list-style:upper-alpha;">
            	<li>Check that each of the values from 1 to 9 can be represented as the sum of two of those bit values in exactly one way.</li>
				<li>There's exactly one more possible set of two of those five bit values; that one represents zero.  What are those two bits?</li>
				<li>How does this help solve the problem of unreliable circuits?</li>
			</ol>
		</div> -->
    
    
    

            </body></html>